---
path: '/blog/how-i-create-world-class-teams'
date: '2020-07-13'
title: 'How I create world class teams'
tags: ['career', 'strategy']
cover: ../../images/cover/amanda-sandlin-jIdKrtJF8Uk-unsplash.jpg
socialCard: ../../images/social-cards/my-career-journey.jpg
---

import TeamStructureImg from './team-structure.png'
import ScrumBoardImg from './undraw_scrum_board_cesn.png'
import BestCodeImg from './best-line-of-code.png'
import BuildVsBuyImg from './build-vs-buy.png'
import BusinessPlanImg from './undraw_business_plan_5i9d.png'

> Strategy is not a lengthy action plan. It is the evolution of a central idea through continually changing circumstances.
*- Jack Welch*

The first time I met my current CEO, Mark, back in 2017 he said something I've never heard any leader admit before. He laid out his strategy and vision and then added, "this is our current product but I'm not afraid to pivot."

There's a reason why this statement has resonated with me so much. Every startup I'd joined prior to this one was led by individuals that coupled their strategy to their execution so closely that they didn't give themselves the opportunity to evolve when circumstances changed. There's a common expectation that to be a leader you have to be right a lot, even when you're wrong. This confidence is necessary especially when you have people to lead. However this shouldn't be at the cost of reality.

Mark showed me that he knew exactly why his company was going to be successful without ever making any prophecies or false promises. He taught me an important lesson about a characteristic of a good leader - **A strong leader doesn't pretend to know all the answers. Instead, they identify the right questions to ask and bring the right people together to answer them**. His strategy was clear. A simple mission that has acted as a guiding light for every decision, action, sale and hire. His strategy wasn't so much a todo list as it was an idea to measure options against.

My goal has always been to create a world class team. I know that's an admirable goal. But without a strategy, that goal is just a dream. Before I felt I was making progress towards that goal, I found myself having to make a lot of decisions, such as:

- What is my team going to build and what can I already buy on the market? Everything this team builds they have to maintain. That's a distraction.
- Where is my team going to be located? Keep them close and I benefit from working with them face to face, but then I'm limiting my options to the people that are physically around me. The chances that me WORLD CLASS team is located near me is very slim. I could create a remote or outsourced team but that creates a whole new set of challenges I would have to overcome, which can become distractions.
- How am I going to find talent? Recruitment is a huge time suck and there's a lot that goes into an effective interview process. I could subsidize the cost of my valuable time by using recruitment agencies, but because I'm creating a new team I'm on a strict budget.

I spent time thinking through the pros and cons to every decision because I wanted to be as objective as possible. I knew by creating the right strategy - a central idea of what I'm going to do decoupled from my current constraints, I'll be able to make solid decisions that I'll be reaping the benefits from for a long time.

## Building your Dream Team

> What one programmer can do in one month, two programmers can do in two months.
*- Fred Brooks*

For a long time I've struggled to come to terms with a fact that contradicts the whole premise of this book. **Software development isn't a team sport.** In fact, I've found forcing the "group hug" mentality is actually counter productive and creates a lot of inefficiencies.

One of the projects I'd been tasked with owning had been around for a number of years. In that time it had accumulated a lot of debt that needed to be paid back and frankly it became a pain to build on top of. Estimates for even the easiest modification were growing because of the complexity and size of the code base. We made the decision to rewrite the front-end in a modern framework and thought it won't be too much trouble because we just need to take what we already have and recreate it. The only condition to getting this projects approval was that we would have to get it done fairly quickly because it hadn't been accounted for in the roadmap and we had clients to go live with.

Instead of just tasking just one or two developers to the job, I put together a team of four along with a project manager and QA resource and set them on their way. I assumed that splitting the work between more resources would result in quicker delivery. This definitely wasn't the case. The larger team actually slowed things down because on top of their regular responsibilities of designing, writing, debugging and testing code they also had to communicate and coordinate with each other. Even when I reduced the scope of the work and the amount of code that would need to be rewritten, the added overhead of clear communication and coordination still outweighed the execution.

For a while I was stuck in analysis paralysis. I'd learned the team was too big for the project and the team was constantly stepping on each others toes trying to keep moving forward, but I also knew if I took people off there would be knowledge gaps that would be hard to fill. I knew there was an answer because I wasn't new to working at scale. Eventually I realized what I was missing. I had to take it back to the beginning. I put my introspective hat on and started thinking about what I did initially to find balance and what questions I had to answer to create a high functioning team when the whole paradigm of "teamwork" felt flawed.

I'd brought together individuals from other, varying sized teams and hadn't sat them down to set clear, explicit expectations between themselves on how to work together. I knew the process that worked for 1 person hadn't carried over when there were 2, and the same at 4. When I'd initially started growing my development team, I'd asked myself some hard questions:

**What are my weaknesses?**

I knew I would become a bottleneck on my team if I tried leading from the front. Instead, I identified my strengths and weaknesses and built a team that complements my strengths while countering my weaknesses.

**Which technology or technologies do I plan to use?**

Was I going to use a technology that you're familiar with or am I comfortable researching technologies that may suit my problem better?

**What's my budget?**

Am I going to hire 2 senior developers or 3 mid level developers? How much time do I have to spend on people management? Am I comfortable delegating architecture responsibilities?

**What's my testing strategy?**

Test driven development or rapid prototypes? Self testing or defined quality process?

**Do I know how I'm going to develop a product?**

Do I already have a way to listen to your audience? How am I going to prioritize one feature over another? Whats my go to market strategy?

Once I started asking these questions of myself, it became as clear as it had in the first place to figure out what to do. Next all I had to do was assess the team structure to make sure I had the right players on the team.

## Team Structure

When I first started building my team team I had to make sure everyone wear multiple hats and work across accountabilities. As the team has grown I've continued to benefit from this structured approach. This is what I've learned about the structure and responsibilities of a typical team outside of just engineering.

<img src={TeamStructureImg} />

### Product Owner

This is a tactical position that works with the team to build the right functionality in a timely manner. The primary function of this role is to take a set of high level business needs and turn them into a detailed technical requirements.

### Project Manager

This is a strategic position that is responsible for managing and leading the team. Their primary function is to efficiently prioritize and optimize the work and ensure the output solves the business needs.

### Developer

The terms "developer" and "software engineer" are generally used interchangeably and typically mean the same thing. I always use the analogy that developers build cars and software engineers build automobiles. The primary function of this position is to apply their technical knowledge to execute on solutions for a given set of requirements either through code or other means.

### Designer

Designers can work across two distinct functions - User Interface (UI) and User Experience (UX). They ensure the product is easy to use and creates a delightful experience. They can conduct user interviews, aid in market research and design solutions with given user personas in mind.

### Quality Assurance

One of the most important positions on any team is Quality Assurance (QA). The role of this individual or individuals is to make sure the product is functional and is being delivered to a high standard. Typically you only have one chance at a first impression with a client and this role is the final line of defense against users having bad experiences.

### Business Analyst

The role of a Business Analyst is to discover ways to iterate and improve the product.They interact with stakeholders and Product Owners to understand the problem scope and focus on using and analyzing object data to find better solutions.

As you create your strategy, you'll find just as I did that a big part of it will be to discover which positions will be useful for your team and keep a pulse check on when the structure needs to evolve. But the most impactful behavior is to constantly re-evaluate and identify new bottlenecks based on the quality of delivery and the roadblocks the team is facing.

## Choose an Operating System

<img src={ScrumBoardImg} />

> If you could get all the people in an organization rowing in the same direction, you could dominate any industry, in any market, against any competition, at any time.
- *The Five Dysfunctions of a Team by Patrick Lencioni*

A great strategy increases predictability. Predictability allows you to be proactive instead of reactive and get ahead of changing circumstances so that you're always prepared. The first step towards predictability is transparency. You have to know where you are so you can plan a path to your destination.

One of my first developer jobs was for a company that was building email marketing software. At the peak there were 7 of us working on different parts of it. When I look back at that time, it was unique in that it gave me an idea of why projects need some sort of operating system or management structure. Let me set the scene.

My manager at the time, Chris, wanted to bring together a "team of entrepreneurs". His thought process was that if you know how to build a project by yourself, you should know how to build a project together. To put it kindly, what followed was chaos. Requirements would change on a whim, rarely was anything documented, the only way to know what someone else was working on was to ask them and there was no clear indication of when the project would be completed. Chris was a great guy and his intent was to emulate the freedom we would have if we were doing things by ourselves, but the cost of that freedom was predictability. As it turns out, the product never launched and that cost was a big price to pay.

Carrying that lesson forward into my next jobs, even when I was the only developer on a team I made sure I understood the value of process and implemented structure so that if the team ever grew we would be able to hit the ground running. I'm not an expert in any of this but I did a lot of research a through experience have learned a lot about what works and what doesn't.

Currently, the most popular operating systems for managing transparency on software development teams is the Agile methodology. The Agile methodology can make your team more flexible by allowing you to adapt and respond to unplanned changes and pivots. It's a set of ideals and principles that serve as a north star to guide your team to continuously deliver value.

The Agile methodology is presented as a manifesto, consisting of 4 Core Values and 12 Principles. The 4 core values are:

1. **Individuals and interactions over processes and tools**
2. **Working software over comprehensive documentation**
3. **Customer collaboration over contract negotiation**
4. **Responding to change over following a plan**

Agile project management methodologies can be as diverse and unique to serve the unique needs of your team, but the following 12 Principles should always guide your decisions and product development:

1. **Our highest priority is to satisfy the customer through early and continuous delivery of valuable software (or whatever else you deliver).**
2. **Welcome changing requirements, even late in development. Agile processes harness change for the customerâ€™s competitive advantage.**
3. **Deliver projects frequently, from a couple of weeks to a couple of months, with a preference for the shorter timescale.**
4. **Coordinating team members must work together daily throughout the project.**
5. **Build projects around motivated individuals. Give them the environment and support they need and trust them to get the job done.**
6. **Face-to-face conversation is the most efficient and effective method of conveying information to and within different teams.**
7. **The final product is the primary measure of progress.**
8. **Agile processes promote sustainable development. All stakeholders should be able to maintain a constant pace indefinitely.**
9. **Continuous attention to technical excellence and good design enhances agility.**
10. **Simplicity - the art of maximizing the amount of work not done - is essential.**
11. **The best architectures, requirements, and designs emerge from self-organizing teams.**
12. **At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.**

Within the Agile methodology there are frameworks for how implement it on your team, such as Scrum and Kanban. These frameworks allow you to break down a large project into smaller chunks and create check in points for you to continue planning or adjust course as necessary.

**Scrum**

Scrum teams commit to ship working software on set intervals, called sprints. They adopt specific roles and hold regular ceremonies to keep things continuously moving forward.

**Kanban**

Kanban is all about visualizing your work, limiting work in progress, and maximizing efficiency. Kanban teams focus on reducing the time it takes to take a project or feature from start to finish. They do this by using a kanban board and continuously improving their flow of work.

Each framework has its own opinion about how to plan, measure and deliver work.

| Area | Scrum | Kanban |
|------|-------|--------|
|Cadence|Regular, fix length "sprints" (typically 2 weeks)|Continuous flow|
|Key Metric|Velocity (the amount of work done per "sprint"|Throughput, WIP|
|Change Philosophy|No changes during a "sprint"|Changes can happen any time|

Which choices you make in terms of operating systems and frameworks is up to you and your specific needs. The best advice I have is to do your research so you can make an informed decision.

## Focusing on the Problem or the Technology?

There's two philosophies when it comes to choosing the right technology for your team.

**First solve the problem. Then write the code.**

What makes your product unique? In most cases it's not the technology used to solve the problem, it's the solution itself. When you have a problem we want to solve we can put it through 3 stages:

- Outline the problem scope
    - What is the underlying problem?
    - Is the perceived problem actually just a symptom of a deeper underlying problem?
- Dive deep in to the problem
    - Do you know everything you need to?
    - Do you have all the facts?
- Create a solution
    - What assumptions are being made?
    - What are the barriers of entry?

I spent a brief period of my life consulting for large enterprises. Most of my experience is with startups so this was a great change of pace to understand systems at scale. One of the biggest differentiators is their willingness to research and choose the right tools for the job. One such consulting position took me to a company that would automate managing hotel room inventory on sites like Orbitz and Expedia. When someone booked a room on one site, the inventory change would propagate across all the other sites. The original system was built using PHP but it got to a point where the language became a bottleneck to scale. The team took a hard look at the problem and decided collectively to learn Java and reimplement the solution. It was a bold move but in the end it worked for them. Once they were done, I asked a few of the developers how they felt about the decision and what they learned.

The general consensus when they looked retrospectively is that it was the right move to make. The big advantage with this approach was that they didn't limit themselves to their abilities or knowledge of technology. This allowed them to actually innovate and create something new.

The biggest downside they experienced was that it created a learning curve that wasn't suited for everyone. The decision was made by the majority rather than having consensus, and some felt forced to either learn the technology or risk being replaced. If this doesn't appeal to you, then you may be better suited for the second option.

**The right technology is the one you're already familiar with.**

Your best work is done when you're doing things you're good at and things that you love. If you already have familiarity with certain technologies, that may be the best place to start. Your competency helps you find like minded individuals that can help you get going and thats a great place to start.

I learned this lesson the hard way. I've had to learn new languages at almost every job I've had. This gave me the mindset that if I can do it, anyone can. Not true! Everyone has different aspirations and motivations. Some want to be generalists and learn a bit of everything, others want to be specialists and be really develop their core competencies.

When I first started with my current company I inherited a big monolithic Ruby application, a language I was totally unfamiliar with. I had to make progress as I learned and that meant figuring out how to work smart. There was no admin panel as such at the time and most of the internal operations such as setting up new clients had to be done manually. I decided to create a simple admin panel using Angular and hand it off to the implementation team to allow them to work autonomously and buy myself some focus time to learn Ruby. It was a decision that I knew wouldn't scale but one that I thought I wouldn't have too much of an impact. When I hired more developers I focused on Ruby and not Angular because I didn't think it mattered. Wrong! What ended up happening was the Angular admin panel became a stress point for the team because nobody else knew or cared about Angular enough to maintain it. We would have had better luck if the technology choice better suited what I was planning to hire for, or if I'd explicitly focused on familiarity with Angular as I grew the team.

## The Build vs Buy Argument

<img src={BestCodeImg} />

You've started building your team and you've created a roadmap of features. Before you start executing there's one more question you need to answer - what do you actually need to build?

It's easy to create a product by stitching other products together. But I've learned that by doing this I lose a lot of control and specificity in functionality. It's just as easy to decide to create everything myself. But by doing this I lose time and increase complexity.

The best way to prioritize what's essential to build is by understanding Return On Investment (ROI). Constantly having the "build vs buy" argument in my own head to optimize on costs and keep things simple has kept my roadmap lean.

<img src={BuildVsBuyImg} />

Over time, the cost of building and maintaining your own software continues to grow, however the cost of buying software can balance out

The four questions I ask myself whenever I have a new feature to build are:

1. Can I build it fast enough?
2. Can I build it well enough?
3. Do I want to maintain it?
4. What else could I spend my time doing?

## Hope is not a Strategy

<img src={BusinessPlanImg} />

The most important trait of a world class team is that everyone is rowing in the same direction. This doesn't happen by chance. Nothing has happened by chance for me. You have to create a plan, constantly evaluate it and be explicit about every decision you make. It takes a strong level of awareness to not only create a world class team, but also make sure they stay that way. Here's some final tips as you think through your own strategy:

- **Invest in experience.** The higher cost of talent will buy you a higher level of strategic thinking, intuition and leadership which all leads to a better quality end result. The optimal team size is between 3 and 9 members, with teams of 7 displaying the most efficiencies. The key here is to carefully manage your team in accordance to your requirements.
- **Personality is as important as skill.** A smart individual with a stubborn personality will cause more harm than good. Surround yourself with people that are able to work together to constantly raise the bar for each other.
- **Put emphasis on professional growth early.** Individual growth will benefit you, invest in it. Make sure your strategy includes the ability for your people to be constantly growing to help you build a better product.
- **Be intentional with decision making.** Consensus management will accelerate your path to entropy. Don't let politics and personal bias get in the way of technical correctness, and don't strive to be a democracy. Trust the smart people to make the hard decisions. Focus on finding the right answer, not winning the most arguments.
- **Equip the team with the right tools.** The worst thing you can do is invest is smart people and create a great plan, but not set them up for success. Without the right tools, very little gets done regardless of anything else.